# KivyAstunutGame
The Astunut Game is a GUI-based Kivy app using Python. This game is about a lonely astronaut who loves music and is on a mission to collect the musical notes of the galaxy which are stars. However, as the level advances, dangerous blackholes appear which will harm his life when it is being shot. Beware of cute yet annoying creatures of space which will try and disturb the astronaut! Help the astronaut to finish his mission and bring him back home! 

<p align=center>
  <img src="https://github.com/joeljhanster/KivyAstrunutGame/blob/master/images/demo.png" width=80% />
</p>

# How to play your game:

To view instructions, click on compass.

To go to the levels page, click start.

Click on one of the 3 stars to access your desired level. 

Player Control keys: ‘A’ to move to the left, ‘D’ to move to the right, ‘W’ to jump up and ‘spacebar’ to shoot hook

To win (finish the mission), you have to clear all three levels with increasing difficulty. 
** The number of stars and obstacles increases according to the level number. **

To advance to the next level: Eliminate all the running cheeky stars by shooting it with your hook. Then, move your player to the portal that will appear to advance to the next level. 

The astronaut has three lives. 
Each blackhole shot will deduct a life from the player. If three blackholes are shot in the level, player loses and will be asked to try again. Click on the replay button to try again! 

At the 3rd level, an annoying yet adorable creature will attempt to push you if you are in the way. When the creature is in contact with the player, you can command it to change its direction by pressing either ‘A’ or ‘D’ for a few seconds to push it back in the opposite direction. OR, you can press ‘W’ to jump over it! Try pressing ‘W’ + ‘A’ or ‘D’ to annoy the creature and cause it to change its direction frantically! This animal can enter from both sides of the window. 

At the winning page, click on the UFO to return to home page. 

# Describe my code: 

My code uses kivy module and random module.  The random module used to randomise positioning and other relevant variables of object in game while kivy module is used to display the game. Applying the concept of OOP to design my game:

Classes: The GameWidget class inherits the set of properties and methods from its parent class Widget. The Entity class is a class which represents the set of properties or methods that are common to all entities created such as their size, position and source of image. 

Object: The player, hooks, explosion, stars, blackholes,animal spawned and portal are objects of classes Player, Hooks, Explosion, Star, Blackhole, Animal and Portal respectively where they define of the state, behaviour and identity of the classes. 

Method: Spawning and removing of entities, movement of player and collision detections are done by executing methods of their own respective classes.

Inheritance: The Star, Hook, Player, Portal, Explosion, Blackhole and Animal are classes that define the source of the image. The classes are all subclasses of the Entity class which allows those classes to inherit the size and position variables from the parent class. The Entity class is a subclass of the Object superclass as well.

Encapsulation: Most of the variables are encapsulated (I add single underscore in front of variables and methods which protects variables and methods from being edited and called respectively outside of class, I add double underscore in fornt of variables and methods to indicate that it is a private variable to suggest strongly that it should not be touched outside of class). An example is the source of the image. Encapsulation prevents the variables from being changed outside of the class. This prevents unintentional modification of the code.


The GameWidget class which is a subclass of Widget is created to display the widgets onto the canvas of the game. To add and remove widgets in the games are done by methods in this class. This includes the adding of entities when a level screen is entered and method `add_entity` is triggered as well as removal of entities when a level screen is exited and method `remove_all` is called which triggers `remove_entity`. The method of detecting collision between two objects and the method of checking if a player has won the round or lost and then transiting to the “LOSE” and “WIN” screen respectively is created in this class. The Clock superclass is used here to repeatedly call the method `_on_frame` for every 0 seconds after each frame such that the player and hook is able to move smoothly on canvas according to when the user presses the keys to trigger their movements. This is the same for the method `checks_win_lose` as well to ensure that the transition of screen is done immediately once player loses or wins the round. 
The Clock superclass is used here instead to because while loop cannot be used in kivy app. A getter and setter is set for the properties of objects such that their attributes are private and cannot be modified outside of the class. 

The position and size of the objects are initially represented by the properties set for class Entity which is a subclass of Object. The `__init__` method in each object’s respective classes allows their properties to override the initialised properties of their superclass Entity using the code line i.e. `super(Hook,self).__init__()` . The image sources of the objects are input in their `self.source` property in their respective classes where a method `__init__` is called. The sounds are played using the module `kivy.core.audio` where the class SoundLoader is used and its function `load` is called with a music file set as its parameter. To play the sound, a function `play()` is called with the class SoundLoader.

For the Star objects, in order them to move around the screen consistently in a random motion, I used the random module and its functions such as uniform and choice.  Random uniform generates four random points in chosen areas i.e. the four sides of the window. Out of these four points, one point will be chosen using random choice to give the new portion of the star object. To make it move to the new position given, the method `change_dir` is being called to ensure that the star object reaches its target point and thus a new position is randomly generated again on any of the sides it is not on. This will always be true after the initialised position because the new positions are always given on the sides of the window which will trigger the `rand_side` method. The star objects are being spawned when `spawn_stars` is being triggered under the method `screen_on_enter` in class MyApp which is called when the level screens are being accessed. The number of stars spawned is dependent on the screen number assigned for each level i.e. Level 1 screen number is 1, hence one star spawned. When `screen_on_leave` method is being called, the star widgets will be removed from screen. 

For the Blackhole objects, in order for them to appear in random positions on the canvas of the window, I used the random module and its function uniform. Random uniform generates the x and y points on the screen for the position of each blackhole object spawned. For the size and position of the blackhole to be different from its initial property set by the superclass Entity , I wrote an `__init__` method which allows the Blackhole class to initialise its attributes for the blackhole objects. The parameter of this method is `self,pos,length` where their values are being set randomly in the `spawn_blackhole` method in class GameWidget. The blackhole objects are being spawned when `spawn_blackhole` is being triggered under the method `screen_on_enter` in class MyApp which is called when the level screens are being accessed. The number of blackholes appearing is determined by the screen number minus one and multiplied by 5.  When `screen_on_leave` method is being called, the blackhole widgets will be removed from screen. 

For the Hook object, in order for it to be released , it is being added onto the screen when `shoot_step` method in Player class is being called when the `spacebar` key is being pressed. The Hook object is initialised to bind with the game and appear constantly moving because of `game.bind(on_frame = self.move_step)`. If the hook object collides with other entities that is in the set of `colliding_entities`, Explosion entity is being added whilst the `stop_callbacks` method is being called to stop it from moving by unbinding it to the game i.e. `game.unbind(on_frame=self.move_step)` and `remove_entity` method is called to remove itself and the object collided from the screen. The live count displayed will decrease by one if collision is with Blackhole. If the hook object moves out of the window frame, `stop_callbacks` method is again being called to stop it from moving and `remove_entity` method is called to remove itself from the screen. 

For the Explosion object, in order for the Explosion object to appear when and where the collision happened, `game.add_entity(Explosion((e.pos[0]-150, e.pos[1]-150)))` is being called under the method `move_step` in class Hook where if collision is between Hook object and other object that is in `colliding_entities` set. In order for it to only appear for 0.1 seconds when there is collision between the hook object and star or blackhole object, I used the `schedule_once` function from Clock class to schedule the `_remove_me` function once in 0.1 seconds to such that the `remove_entity` function from GameWidget class is called to remove the explosion object from screen. 

For the Animal object, in order for it to move a step after every frame, the `move_step` method in class Animal is being called using `schedule_interval` from the class Clock with an interval of 0 seconds. In order for the animal to change directions when being pushed by the player, a command variable is being returned as true from the method `push_animal` which is then calls the method `move_step` in class Animal and triggers the method `change_direction` in the same class. An example is that if it is moving to the right while the player pushes it to the left, it will change direction to the left and continue walking in that direction unless being pushed again. In order for it to appear from the opposite side of the window when it exists a side of the window, a condition is applied i.e if its direction is to the `"right"` and it’s x position exceeds the window width, it will be given a new x position at x = 0 minus its size such that it appears as though it is entering the screen from the `"left"`. 

For the Player object, in order for it to move in specific directions only when pressed, `move_step` method in class Player is being called when user presses ‘a’ indicating going to the left, ‘d’ indicating going to the right which is in the set of keysPressed in class GameWidget. In order for the player to jump, user must press the key ‘w’ which is in the set of keysPressed in class GameWidget which will then call `move_step` method in class Player. Hence, the `step_size` value of the player is added to its original y position, giving it an increased height, hence appear jumping. This `move_step` method is initialised to bind to the GameWidget class so that it is always repeatedly called using the `Clock.schdeule_interval` function and hence move a step after every frame if condition is met. The `step_size` property of the player is set to be 350 multiply the time frame such that the speed of the player moving is consistent on any laptop that has a different frame rate. This step_size is the variable that allows the player, animal and star objects to move. In order for it to be pushed by the animal to and move with it, the method `with_animal` is called whenever the animal position is in the range of the position of the player. The new x and y position of the player will then take the positions of the animal object and hence appear moving with it.   In order for the player to jump over the animal and avoid being pushed by the animal, the user must press ‘w’ + ‘a’ or ‘d’ keys depending on the direction of the animal to jump over it. At the instance that key ‘w’ is pressed, the x position of player does not take the position of the animal. Hence, allowing the player to jump over the animal. This method `with_animal` also allows the player to push the animal but not command it to change direction i.e. if ‘a’ key is pressed, the player and animal will move to the right until a distance moved is met, hence the `command_animal` method will be called. In order for the player to command the animal to change direction, the method `command_animal` is called which will return a command variable = `True` if the conditions are met and hence trigger `change_direction` method in class Animal or `False` if conditions not met hence animal will not change its direction. In order for the player to stay within the window boundary, the x position of player is set to be in the range of the window width in `move_step` method. In order for the player to shoot hooks, the method `shoot_step` is called when ‘w’ key is pressed, hence it will trigger method ‘add_entity’ which will add the Hook objects to canvas. In order for the player to appear at every level, the method `add_entity` for Player widget is written outside of the class such that the function is always called due to the features of Kivy. 

For the Portal object, in order for it to appear only when all the stars are eliminated, the method `checks_win_lose` is called when the number of stars on screen is 0 and that it is called when on screen level 1 or 2, the method `spawn_portal` is then called to trigger `add_entity` which will then add the Portal widget. In order for the portal to transfer the player to the next level when player walks into it, the method `spawn_portal` is called which will trigger the code line `manager.current = “LEVEL{}”.format(self.levels +1)` if the condition of player position is within the range of the position of the portal is met. The string in the line of code called will then be changed to the name of the next level and hence the next level screen will appear as the current screen. This is further described in ScreenManager. 

To display the live count, I assigned the class `CoreLabel’ and set text = ‘Lives: `, font size and type properties as the parameter to the variable `self._lives_label`. To call the variable, I used the function `refresh()` with it. The live count decreases when there is collision between the Hook and Blackhole, hence game.lives -= 1. If the value of `self.lives` is 0, the ‘current’ function from ScreenManager with `“LOSE”` assigned to it will transit the screen to the `“LOSE”` screen. 

The window size is set using the module `kivy.core.window` to import class Window and its function `size`.

ScreenManager is an object of Widget class and manages multiple screens.  The individual screen classes are created by setting them as the parameter of the `add_widget` method to the screen manager. To display whichever screen, I use call the `current` function of ScreenManager class to command the screen that is set as its parameter. The interface of the individual screens are in the kv file which will be called as classes in the python file. The individual screens are arranged in order such that they correspond to the variables in ScreenManager. These screens are added before the GameWidget as the background. 

To design the layout of the screens, I use BoxLayout as the parent and created the subclasses such as orientation and Floatlayout, Button, Label and GridLayout. The subclasses carries the properties of their parents. An example would be the subclass `Image` for `LevelsScreen` where the size of the image takes the size of its parent `Button` such that they are scaled the same. It can be scaled by giving ‘True’ to the `allow_stretch` function. The position of the layouts are set by `pos_hint` , size set by `size`. The image source of the button is input using the `source` method under Image class. 

For the background images of the individual screen, I used `canvas.before` method and class Rectangle under FloatLayout to set its property such as `pos`, `size` and `source` of image. 

To change from a screen to another screen, I use the button feature in kivy and bind the button to a specific screen. For example, I use kivy code to bind function `play_plop_sound` in class MyApp to button when clicked. Upon clicking `on_press`, the event button is dispatched. The function `play_plop_sound` calls the play function on object `plop_sound`, after which the `current` variable in Manager object is assigned screenName. screenName is a parameter that is the name of the screen that will be displayed. This is the same for method `play_star_sound` when a star button is pressed. To make the transitions of screen have a fade effect, `FadeTransition()` assigned to transition which is the parameter of ScreenManager in python file.

For advancements of level, as previously mentioned, is by the player entering the portal. The current variable of manager object is assigned a string of the next level. On entering the screen, the method `screen_on_enter` in class MyApp is called and runs the line `currently_screen.ids[‘layout_lvl’+str(screenNum0].add_widget(game)` which will add the GameWidget on top of the layout levels of Kivy. Hence, display the game. When the screen is exited, the function `on_pre_leave` is triggered and calls the method `screen_on_leave` in class MyApp to remove the game widget. Unique `id` is assigned for every level, such that the `ids` function called with `curr_screen` variable is able to identify and display the the screen corresponding to the `id`. 

For Button, the colour is set using the `background_colour`function where I input the RGB colour coordinates (0,0,0,0). The fourth coordinate determines whether the colour is shown or not. The text shown on the button is assigned to `text` under class Button. Font size of the text is assigned to `font_size`. Font type source is assigned to function `font_name`. The position of the button is assigned to the function `pos_hint`. Size of button is assigned to method `size`.

For labels, I used `Label` class and assigned a string to the `text` function. The colour of the text is determined by the RGB colour coordinates which is assigned the the function `colour`. Font size is assigned to method `font_size`. Font type source is assigned to function `font_name`. The position of the label is assigned to the function `pos_hint`.

Building the Astunut App, I created class MyApp which is a subclass of App. To enable background music to play when I first open the game, the method `on_start` is called and will trigger the `load` method in `SoundLoader` class with the music file set as its parameter. To play the music on loop, the method `loop` is called and assigned true. For Home to be the default page when game is opened, `“HOME”` is assigned to the `current` method in class ScreenManager under the method `build`. 

To load the kv file, the name of the file `“astronaut.kv”` is passed as an argument into the function `load_file` in class Builder.

To run the code: `python main.py` 
